{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww8900\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs24 \cf0 WSN: wireless sensor network\
\
sudo apt-get install miniterm\
$ miniterm.py /dev/ttyUSB0 baud_rate->this has to be a number, has to agree with call to init, maybe 115200\
\
\
lib.rs::\
\
let nrf_uart = nrf51822::uart::UART::new()\
nrf_uart.init();\
\
nrf_uart.enable_tx();\
while(nrf_uart.txready())\{\}\
nrf_uart.send_byte(\'91g\'92 as u8);\
\
\
\
for storm, let\'92s explore kernel\
execution begins in src/ships/chip\
e.g. sam4l\
code sets up vector table- initial stack (pointer), pointer to start funtion (reset handler in ARM)\
_estack->in stack reg\
second entry-> pC reg\
first thing hardware does ^\
\
reset_handler for sam4l\
\
jumps to main/main.rs\
\
2 steps before execution\
1. init platform, platform\'92s init fn is called, all the setup for driber tree is done\
2. &_sapps-> pointer to where apps are stored, loads into memory\
2. scheduler, in every loop, run all the interrupts \
efi-> wait for interrupts\
13.25\
\
\
2 levels for handling interrupts-\
1. ISR (arm terminology) - hardware triggers interrupt\
13.29 (in sam4l/usart.rs)\
2. loop that calls platform.service pending interrupts sam4l/uasrt.rs\
look at sam4l/chip.rs\
\
}